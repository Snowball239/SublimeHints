\section{Исследование утилиты Make}

Для исследования утилиты, необходимо разбить программу из предыдущего раздела на следующие файлы:
\begin{enumerate}
 \item \texttt{quicksort.h} - заголовочный файл с прототипами функций быстрой сортировки
 \item \texttt{quicksort.c} - реализация функций из соответствующего заголовка
 \item \texttt{main.c} - функция \texttt{main}
\end{enumerate}

Простейший Makefile состоит из синтаксических конструкций всего двух типов: целей и макроопределений.

Цель в Makefile - это файл(ы), построение которого предполагается в процессе компиляции проекта.
Описание цели состоит из трех частей: имени цели, списка зависимостей и списка команд интерпретатора sh, требуемых для построения цели:
\begin{itemize}
 \item Имя цели - непустой список файлов, которые предполагается создать
 \item Список зависимостей - список файлов, из которых строится цель
\end{itemize}

Имя цели и список зависимостей составляют заголовок цели, записываются в одну строку и разделяются двоеточием.
Список команд записывается со следующей строки, причем все команды начинаются с обязательного символа табуляции.
Возможна многострочная запись заголовка или команд через применение символа "\textbackslash" для экранирования конца строки.
При вызове команды make, если ее аргументом явно не указана цель, будет обрабатываться первая найденная в Makefile цель, имя которой не начинается с символа ".".

В Makefile могут использоваться макроопределения вида \textit{"ПЕРЕМЕННАЯ = ЗНАЧЕНИЕ". ЗНАЧЕНИЕ}.
Макроопределение может являться произвольной последовательностью символов, включая пробелы и обращения к значениям уже определенных переменных.
В дальнейшем, в любом месте Makefile, где встретится обращение к переменной-макроопределению, вместо нее будет подставлено ее текущее значение.
Обращение к значению переменной в любом месте Makefile выглядит как \$(\textit{ПЕРЕМЕННАЯ}). Значение еще не определенных переменных - пустая строка.

Обычно Makefile пишется так, чтобы простой запуск make приводил к компиляции проекта, однако, помимо компиляции,
Makefile может использоваться и для выполнения других вспомогательных действий, напрямую не связанных с созданием каких-либо файлов.
К таким действиям относится очистка проекта от всех результатов компиляции, или вызов процедуры инсталляции проекта в системе.
Для выполнения подобных действий в Makefile могут быть указаны дополнительные цели, обращение к которым будет осуществляться указанием их имени аргументом вызова \texttt{make}
(например, \texttt{make install}). Подобные вспомогательные цели носят название фальшивых, что связанно с отсутствием в проекте файлов, соответствующих их именам.
Фальшивая цель может содержать список зависимостей и должна содержать список команд для исполнения.
Поскольку фальшивая цель не имеет соответствующего файла в проекте, при каждом обращении к ней make будет пытаться ее построить.
Однако, возможно возникновение конфликтной ситуации, когда в каталоге проекта окажется файл с именем, соответствующим имени фальшивой цели.
Если для данного имени не определены файловые зависимости, он будет всегда считаться актуальным (up to date) и цель выполняться не будет.
Для предотвращения таких ситуаций make поддерживает "встроенную" переменную \texttt{.PHONY}, которой можно присвоить список имен целей, которые всегда должны считаться фальшивыми.
Make поддерживает большой набор встроенных переменных, а также метапеременные, принимающие разные значения в зависимости от контекста применения.
Например, \$* соответствует имени целевого файла без суффиксов, а \$\^{} - полному списку зависимостей для данной цели.

Ниже приведен пример Makefile для данного проекта:
\lstinputlisting[language = make]{../quicksort_v2/Makefile}

Make также обладает возможностью условной компоновки при помощи условных конструкций.
Условная конструкция заставляет make обрабатывать или игнорировать часть Makefile в зависимости от значения некоторых переменных.
В качестве условия может использоваться сравнение двух переменных или сравнение переменной с константной строкой.
Например, можно использовать условные конструкции для использования различных компиляторов:

\lstinputlisting[language = make]{../quicksort_v2/Makefile2}

В результате, если определить переменную \texttt(USE\_CLANG), то вместо компилятора gcc будет использован компилятор clang:

\begin{figure}[h]
  \centering
    \includegraphics[width=0.7\textwidth]{img/conditionalMake.png}
  \caption{Выбор различных компиляторов}
\end{figure}
